/*
This file is part of SoftwareDefinedRadio4JUCE.

SoftwareDefinedRadio4JUCE is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public License
as published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

SoftwareDefinedRadio4JUCE is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with SoftwareDefinedRadio4JUCE. If not, see <http://www.gnu.org/licenses/>.
*/

#include "VectorOperations.h"

#ifdef NTLAB_USE_AVX2
// Loads a 8-element complex float vector (--> 16 floats in memory) into two sub vectors inLo and inHi using aligned load
#define NTLAB_AVX2_LOAD_COMPLEX_SUB_VECTORS_ALIGNED_FLOAT(cplxIn, i) __m256 inLo = _mm256_load_ps(reinterpret_cast<const float*>(cplxIn + (i * SIMDHelpers::simdVectorLengthFloat))); \
                                                                     __m256 inHi = _mm256_load_ps(reinterpret_cast<const float*>(cplxIn + (i * SIMDHelpers::simdVectorLengthFloat) + 4))

// Loads a 8-element complex float vector (--> 16 floats in memory) into two sub vectors inLo and inHi using unaligned load
#define NTLAB_AVX2_LOAD_COMPLEX_SUB_VECTORS_UNALIGNED_FLOAT(cplxIn, i) __m256 inLo = _mm256_loadu_ps(reinterpret_cast<const float*>(cplxIn + (i * SIMDHelpers::simdVectorLengthFloat))); \
                                                                       __m256 inHi = _mm256_loadu_ps(reinterpret_cast<const float*>(cplxIn + (i * SIMDHelpers::simdVectorLengthFloat) + 4))

// Extract 8 real values out of the two sub-vectors loaded, however returning them in a wrong order
#define NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_REAL_VALUES_FLOAT _mm256_shuffle_ps(inLo, inHi, _MM_SHUFFLE (2, 0, 2, 0))

// Extract 8 imaginary values out of two sub-vectors loaded, however returning them in a wrong order
#define NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_IMAG_VALUES_FLOAT _mm256_shuffle_ps(inLo, inHi, _MM_SHUFFLE (3, 1, 3, 1))

// Reorder the 8 values generated by the above two functions
#define NTLAB_AVX2_REORDER_SHUFFLED_FLOAT(unsorted) _mm256_castpd_ps(_mm256_permute4x64_pd (_mm256_castps_pd(unsorted), _MM_SHUFFLE (3, 1, 2, 0)))
#endif

namespace ntlab
{
    template<>
    void SIMDHelpers::Partition<double>::forArbitraryLengthVector (const int vectorLength, int& numSIMDVectors, int& numElementsToProcessWithSIMD, int& numElementsRemainingToProcessWithoutSIMD)
    {
        numSIMDVectors = vectorLength / simdVectorLengthDouble;
        numElementsToProcessWithSIMD = numSIMDVectors * simdVectorLengthDouble;
        numElementsRemainingToProcessWithoutSIMD = vectorLength - numElementsToProcessWithSIMD;
    }

    template<>
    void SIMDHelpers::Partition<float>::forArbitraryLengthVector (const int vectorLength, int& numSIMDVectors, int& numElementsToProcessWithSIMD, int& numElementsRemainingToProcessWithoutSIMD)
    {
        numSIMDVectors = vectorLength / simdVectorLengthFloat;
        numElementsToProcessWithSIMD = numSIMDVectors * simdVectorLengthFloat;
        numElementsRemainingToProcessWithoutSIMD = vectorLength - numElementsToProcessWithSIMD;
    }

    template<>
    void SIMDHelpers::Partition<int32_t>::forArbitraryLengthVector (const int vectorLength, int& numSIMDVectors, int& numElementsToProcessWithSIMD, int& numElementsRemainingToProcessWithoutSIMD)
    {
        numSIMDVectors = vectorLength / simdVectorLengthInt32;
        numElementsToProcessWithSIMD = numSIMDVectors * simdVectorLengthInt32;
        numElementsRemainingToProcessWithoutSIMD = vectorLength - numElementsToProcessWithSIMD;
    }

    template<>
    void SIMDHelpers::Partition<int16_t>::forArbitraryLengthVector (const int vectorLength, int& numSIMDVectors, int& numElementsToProcessWithSIMD, int& numElementsRemainingToProcessWithoutSIMD)
    {
        numSIMDVectors = vectorLength / simdVectorLengthInt16;
        numElementsToProcessWithSIMD = numSIMDVectors * simdVectorLengthInt16;
        numElementsRemainingToProcessWithoutSIMD = vectorLength - numElementsToProcessWithSIMD;
    }

    template<>
    constexpr int SIMDHelpers::VectorLength<double>::numValues() {return simdVectorLengthDouble; }

    template<>
    constexpr int SIMDHelpers::VectorLength<float>::numValues() {return simdVectorLengthFloat; }

    template<>
    constexpr int SIMDHelpers::VectorLength<int32_t>::numValues() {return simdVectorLengthInt32; }

    template<>
    constexpr int SIMDHelpers::VectorLength<int16_t>::numValues() {return simdVectorLengthInt16; }

#if NTLAB_USE_AVX2

    void ComplexVectorOperations::extractRealPart (const std::complex<float>* complexInVector, float* realOutVector, int length)
    {
        int numSIMDIterations, numElementsToProcessWithSIMD, numElementsToProcessWithoutSIMD;
        SIMDHelpers::Partition<float>::forArbitraryLengthVector (length, numSIMDIterations, numElementsToProcessWithSIMD, numElementsToProcessWithoutSIMD);

        if (SIMDHelpers::isPointerAligned (complexInVector) && SIMDHelpers::isPointerAligned (realOutVector))
        {
            for (int i = 0; i < numSIMDIterations; ++i)
            {
                NTLAB_AVX2_LOAD_COMPLEX_SUB_VECTORS_ALIGNED_FLOAT (complexInVector, i);

                __m256 realPartVec = NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_REAL_VALUES_FLOAT;
                realPartVec = NTLAB_AVX2_REORDER_SHUFFLED_FLOAT (realPartVec);

                _mm256_store_ps (realOutVector + (i * SIMDHelpers::simdVectorLengthFloat), realPartVec);
            }
        }
        else
        {
            for (int i = 0; i < numSIMDIterations; ++i)
            {
                NTLAB_AVX2_LOAD_COMPLEX_SUB_VECTORS_UNALIGNED_FLOAT (complexInVector, i);

                __m256 realPartVec = NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_REAL_VALUES_FLOAT;
                realPartVec = NTLAB_AVX2_REORDER_SHUFFLED_FLOAT (realPartVec);

                _mm256_storeu_ps (realOutVector + (i * SIMDHelpers::simdVectorLengthFloat), realPartVec);
            }
        }

        extractRealPartNonSIMD (complexInVector + numElementsToProcessWithSIMD,
                realOutVector + numElementsToProcessWithSIMD,
                numElementsToProcessWithoutSIMD);
    }

    void ComplexVectorOperations::extractImagPart (const std::complex<float>* complexInVector, float* imagOutVector, int length)
    {
        int numSIMDIterations, numElementsToProcessWithSIMD, numElementsToProcessWithoutSIMD;
        SIMDHelpers::Partition<float>::forArbitraryLengthVector (length, numSIMDIterations, numElementsToProcessWithSIMD, numElementsToProcessWithoutSIMD);

        if (SIMDHelpers::isPointerAligned (complexInVector) && SIMDHelpers::isPointerAligned (imagOutVector))
        {
            for (int i = 0; i < numSIMDIterations; ++i)
            {
                NTLAB_AVX2_LOAD_COMPLEX_SUB_VECTORS_ALIGNED_FLOAT (complexInVector, i);

                __m256 imagPartVec = NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_IMAG_VALUES_FLOAT;
                imagPartVec = NTLAB_AVX2_REORDER_SHUFFLED_FLOAT (imagPartVec);

                _mm256_store_ps (imagOutVector + (i * SIMDHelpers::simdVectorLengthFloat), imagPartVec);
            }
        }
        else
        {
            for (int i = 0; i < numSIMDIterations; ++i)
            {
                NTLAB_AVX2_LOAD_COMPLEX_SUB_VECTORS_UNALIGNED_FLOAT (complexInVector, i);

                __m256 imagPartVec = NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_IMAG_VALUES_FLOAT;
                imagPartVec = NTLAB_AVX2_REORDER_SHUFFLED_FLOAT (imagPartVec);

                _mm256_storeu_ps (imagOutVector + (i * SIMDHelpers::simdVectorLengthFloat), imagPartVec);
            }
        }

        extractImagPartNonSIMD (complexInVector + numElementsToProcessWithSIMD,
                imagOutVector + numElementsToProcessWithSIMD,
                numElementsToProcessWithoutSIMD);
    }

    void ComplexVectorOperations::extractRealAndImagPart (const std::complex<float>* complexInVector, float* realOutVector, float* imagOutVector, int length)
    {
        int numSIMDIterations, numElementsToProcessWithSIMD, numElementsToProcessWithoutSIMD;
        SIMDHelpers::Partition<float>::forArbitraryLengthVector (length, numSIMDIterations, numElementsToProcessWithSIMD, numElementsToProcessWithoutSIMD);

        if (SIMDHelpers::isPointerAligned (complexInVector) && SIMDHelpers::isPointerAligned (realOutVector) && SIMDHelpers::isPointerAligned (imagOutVector))
        {
            for (int i = 0; i < numSIMDIterations; ++i)
            {
                NTLAB_AVX2_LOAD_COMPLEX_SUB_VECTORS_ALIGNED_FLOAT (complexInVector, i);

                __m256 realPartVec = NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_REAL_VALUES_FLOAT;
                realPartVec = NTLAB_AVX2_REORDER_SHUFFLED_FLOAT (realPartVec);

                __m256 imagPartVec = NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_IMAG_VALUES_FLOAT;
                imagPartVec = NTLAB_AVX2_REORDER_SHUFFLED_FLOAT (imagPartVec);

                _mm256_store_ps (imagOutVector + (i * SIMDHelpers::simdVectorLengthFloat), imagPartVec);
                _mm256_store_ps (realOutVector + (i * SIMDHelpers::simdVectorLengthFloat), realPartVec);
            }
        }
        else
        {
            for (int i = 0; i < numSIMDIterations; ++i)
            {
                NTLAB_AVX2_LOAD_COMPLEX_SUB_VECTORS_UNALIGNED_FLOAT (complexInVector, i);

                __m256 realPartVec = NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_REAL_VALUES_FLOAT;
                realPartVec = NTLAB_AVX2_REORDER_SHUFFLED_FLOAT (realPartVec);

                __m256 imagPartVec = NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_IMAG_VALUES_FLOAT;
                imagPartVec = NTLAB_AVX2_REORDER_SHUFFLED_FLOAT (imagPartVec);

                _mm256_storeu_ps (imagOutVector + (i * SIMDHelpers::simdVectorLengthFloat), imagPartVec);
                _mm256_storeu_ps (realOutVector + (i * SIMDHelpers::simdVectorLengthFloat), realPartVec);
            }
        }

        extractRealAndImagPartNonSIMD (complexInVector + numElementsToProcessWithSIMD,
                realOutVector + numElementsToProcessWithSIMD,
                imagOutVector + numElementsToProcessWithSIMD,
                numElementsToProcessWithoutSIMD);
    }

    void ComplexVectorOperations::abs (const std::complex<float>* complexInVector, float* absOutVector, int length)
    {
        int numSIMDIterations, numElementsToProcessWithSIMD, numElementsToProcessWithoutSIMD;
        SIMDHelpers::Partition<float>::forArbitraryLengthVector (length, numSIMDIterations, numElementsToProcessWithSIMD, numElementsToProcessWithoutSIMD);

        if (SIMDHelpers::isPointerAligned (complexInVector) && SIMDHelpers::isPointerAligned (absOutVector))
        {
            for (int i = 0; i < numSIMDIterations; ++i)
            {
                NTLAB_AVX2_LOAD_COMPLEX_SUB_VECTORS_ALIGNED_FLOAT (complexInVector, i);

                __m256 realPartVec = NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_REAL_VALUES_FLOAT;
                __m256 imagPartVec = NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_IMAG_VALUES_FLOAT;

                __m256 absVec = _mm256_sqrt_ps (_mm256_add_ps (_mm256_mul_ps (realPartVec, realPartVec), _mm256_mul_ps (imagPartVec, imagPartVec)));

                _mm256_store_ps (absOutVector + (i * SIMDHelpers::simdVectorLengthFloat), NTLAB_AVX2_REORDER_SHUFFLED_FLOAT (absVec));
            }
        }
        else
        {
            for (int i = 0; i < numSIMDIterations; ++i)
            {
                NTLAB_AVX2_LOAD_COMPLEX_SUB_VECTORS_UNALIGNED_FLOAT (complexInVector, i);

                __m256 realPartVec = NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_REAL_VALUES_FLOAT;
                __m256 imagPartVec = NTLAB_AVX2_SHUFFLE_OUT_UNORDERED_IMAG_VALUES_FLOAT;

                __m256 absVec = _mm256_sqrt_ps (_mm256_add_ps (_mm256_mul_ps (realPartVec, realPartVec), _mm256_mul_ps (imagPartVec, imagPartVec)));

                _mm256_storeu_ps (absOutVector + (i * SIMDHelpers::simdVectorLengthFloat), NTLAB_AVX2_REORDER_SHUFFLED_FLOAT (absVec));
            }
        }

        absNonSIMD (complexInVector + numElementsToProcessWithSIMD, absOutVector + numElementsToProcessWithSIMD, numElementsToProcessWithoutSIMD);
    }

#elif NTLAB_USE_NEON

#elif NTLAB_NO_SIMD

    forcedinline void ComplexVectorOperations::extractRealPart (const std::complex<float>* complexInVector, float* realOutVector, int length)
    {
        extractRealPartNonSIMD (complexInVector, realOutVector, length);
    }

    forcedinline void ComplexVectorOperations::extractImagPart (const std::complex<float>* complexInVector, float* imagOutVector, int length)
    {
        extractRealPartNonSIMD (complexInVector, imagOutVector, length);
    }

    forcedinline void ComplexVectorOperations::extractRealAndImagPart (const std::complex<float>* complexInVector, float* realOutVector, float* imagOutVector, int length)
    {
        extractRealAndImagPartNonSIMD (complexInVector, realOutVector, imagOutVector, length);
    }

    forcedinline void ComplexVectorOperations::abs (const std::complex<float>* complexInVector, float* absOutVector, int length)
    {
        absNonSIMD (complexInVector, absOutVector, length);
    }

#endif


#ifdef NTLAB_SOFTWARE_DEFINED_RADIO_UNIT_TESTS

    class VectorOperationsTests : public juce::UnitTest
    {
    public:
        VectorOperationsTests () : juce::UnitTest ("VectorOperations test") {};

        void runTest () override
        {
            beginTest ("Aligned allocation");

            auto complexSrc = SIMDHelpers::Allocation<std::complex<float>>::allocateAlignedVector (vecSize);
            auto realDst = SIMDHelpers::Allocation<float>::allocateAlignedVector (vecSize);
            auto imagDst = SIMDHelpers::Allocation<float>::allocateAlignedVector (vecSize);
            auto absDst  = SIMDHelpers::Allocation<float>::allocateAlignedVector (vecSize);

            auto random = getRandom();
            for (int i = 0; i < vecSize; ++i)
                complexSrc[i] = std::complex<float> (random.nextFloat(), random.nextFloat());

            beginTest ("Extract real part");
            ComplexVectorOperations::extractRealPart (complexSrc, realDst, vecSize);
            bool allValuesEqual = true;
            for (int i = 0; i < vecSize; ++i)
                if (!juce::approximatelyEqual (complexSrc[i].real(), realDst[i]))
                {
                    allValuesEqual = false;
                    break;
                }
            expect (allValuesEqual);

            beginTest ("Extract imag part");
            ComplexVectorOperations::extractImagPart (complexSrc, imagDst, vecSize);
            allValuesEqual = true;
            for (int i = 0; i < vecSize; ++i)
                if (!juce::approximatelyEqual (complexSrc[i].imag(), imagDst[i]))
                {
                    allValuesEqual = false;
                    break;
                }
            expect (allValuesEqual);

            beginTest ("Extract real and imag part");
            for (int i = 0; i < vecSize; ++i)
                complexSrc[i] = std::complex<float> (random.nextFloat(), random.nextFloat());
            ComplexVectorOperations::extractRealAndImagPart (complexSrc, realDst, imagDst, vecSize);
            allValuesEqual = true;
            for (int i = 0; i < vecSize; ++i)
                if (!(juce::approximatelyEqual (complexSrc[i].real(), realDst[i]) && juce::approximatelyEqual (complexSrc[i].imag(), imagDst[i])))
                {
                    allValuesEqual = false;
                    break;
                }
            expect (allValuesEqual);

            beginTest ("Extract abs part");
            ComplexVectorOperations::abs (complexSrc, absDst, vecSize);
            allValuesEqual = true;
            for (int i = 0; i < vecSize; ++i)
                if (!juce::approximatelyEqual (std::abs (complexSrc[i]), absDst[i]))
                {
                    allValuesEqual = false;
                    break;
                }
            expect (allValuesEqual);

            beginTest ("Free aligned memory");
            SIMDHelpers::Allocation<std::complex<float>>::freeAlignedVector (complexSrc);
            SIMDHelpers::Allocation<float>::freeAlignedVector (realDst);
            SIMDHelpers::Allocation<float>::freeAlignedVector (imagDst);
            SIMDHelpers::Allocation<float>::freeAlignedVector (absDst);
        }

    private:
        static const int vecSize = 1999;
    };

    static VectorOperationsTests vectorOperationsTests;
#endif

}