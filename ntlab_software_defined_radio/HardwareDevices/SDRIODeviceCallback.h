/*
This file is part of SoftwareDefinedRadio4JUCE.

SoftwareDefinedRadio4JUCE is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public License
as published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

SoftwareDefinedRadio4JUCE is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with SoftwareDefinedRadio4JUCE. If not, see <http://www.gnu.org/licenses/>.
*/

#pragma once

#include "../SampleBuffers/SampleBuffers.h"

namespace ntlab
{
    class StreamingError
    {
    public:
        virtual ~StreamingError() {};

        /** Returns true if the error is generated by dropped samples. If true you can query the number of samples
         * dropped through @see numRxSamplesDropped and @see numTxSamplesDropped
         */
        virtual bool isSampleDropError () const = 0;

        /**
         * Returns the number of Rx samples dropped or -1 if unknown. The value returned might be an estimate, depending
         * on the Engine implementation
         */
        virtual int numRxSamplesDropped () const = 0;

        /**
         * Returns the number of Tx samples dropped or -1 if unknown. The value returned might be an estimate, depending
         * on the Engine implementation
         */
        virtual int numTxSamplesDropped () const = 0;

        /** Returns a human readable error description */
        virtual juce::StringRef getErrorDescription () const = 0;

        const char* getErrorDescriptionCString() const { return static_cast<const char*> (getErrorDescription()); }
    };

    // creates a sample drop error with unspecified number of dropped samples. It's best for all Engines that can
    // create a sample drop to keep an instance as member and just set a matching number of dropped samples in
    // case a sample drop occurs
    class SampleDropError : public StreamingError
    {
    public:
        SampleDropError() {}

        void setNumRxSampsDropped (int numSampsDropped) { numRxSampsDropped = numSampsDropped; }

        void setNumTxSampsDropped (int numSampsDropped) { numTxSampsDropped = numSampsDropped; }

        bool isSampleDropError() const override { return true; }

        int numRxSamplesDropped() const override { return numRxSampsDropped; }

        int numTxSamplesDropped() const override { return numTxSampsDropped; }

        juce::StringRef getErrorDescription() const override
        {
            static juce::String errorDescription = "Dropped " +
                    ((numRxSampsDropped < 0) ? "an unknown amount of" : juce::String (numRxSampsDropped)) +
                    " rx samples and " +
                    ((numTxSampsDropped < 0) ? "an unknown amount of" : juce::String (numTxSampsDropped)) +
                    " tx samples";

            return errorDescription;
        }
    private:
        int numRxSampsDropped = -1;
        int numTxSampsDropped = -1;
    };

    // A lightweight object that just holds a StringRef to pass an external string to the error. Should be created
    // on the stack
    class GeneralErrorMessageNonOwning : public StreamingError
    {
    public:
        GeneralErrorMessageNonOwning (juce::StringRef description) : errorDescription (description) {};

        bool isSampleDropError() const override { return false; }

        int numRxSamplesDropped() const override { return 0; }

        int numTxSamplesDropped() const override { return 0; }

        juce::StringRef getErrorDescription() const override { return errorDescription; }

    private:
        const juce::StringRef errorDescription;
    };

    // An object that own a String to pass as error.
    class GeneralErrorMessageOwning : public StreamingError
    {
    public:
        GeneralErrorMessageOwning (juce::String&& description) : errorDescription (description) {}

        GeneralErrorMessageOwning (juce::String& description)  : errorDescription (description) {}

        void setErrorMessage (juce::String& newDescription) { errorDescription = newDescription; }

        bool isSampleDropError() const override { return false; }

        int numRxSamplesDropped() const override { return 0; }

        int numTxSamplesDropped() const override { return 0; }

        juce::StringRef getErrorDescription() const override { return errorDescription; }
    private:
        juce::String errorDescription;
    };

#if NTLAB_USE_CL_SAMPLE_BUFFER_COMPLEX_FOR_SDR_IO_DEVICE_CALLBACK
    using OptionalCLSampleBufferComplexFloat = CLSampleBufferComplex<float>;
#else
    using OptionalCLSampleBufferComplexFloat = SampleBufferComplex<float>;
#endif

    /**
     * A pure virtual interface class describing the interface any class needs to implement that should continously
     * process samples from an SDR IO device. processRFSampleBlock will be called repeatedly on a high-priority thread.
     * As real-time-safe application rely on a predictable, fast as possible return time of this call make sure to
     * never perform any system call like memory allocation, console prints, etc from within this callback as those
     * operations might not return after a predictable amount of time depending on the operating system load and other
     * factors. To allocate ressources use prepareForStreaming, which will be guranteed to be called before the first
     * callback to processRFSampleBlock. To free ressources after streaming use the streamingHasStopped callback which
     * will be guranteed to be called after the last call to processRFSampleBlock.
     */
    class SDRIODeviceCallback
    {
    public:
        virtual ~SDRIODeviceCallback() {};

        /**
         * This is the place to set up all your ressources (buffers, DSP blocks, etc.) to get them ready for
         * continously streaming samples.
         */
        virtual void prepareForStreaming (double sampleRate, int numActiveChannelsIn, int numActiveChannelsOut, int maxNumSamplesPerBlock) = 0;

        /**
         * This callback will be called repeatedly on a high-priority thread to process the next block of samples. Keep
         * in mind that depending on your setup either the channel count of the input buffer as well as the channel
         * count of the output buffer could be zero. If either the rx or tx path is currently disabled the sample count
         * of the corresponding buffer is guaranteed to be zero.
         */
        virtual void processRFSampleBlock (OptionalCLSampleBufferComplexFloat& rxSamples, OptionalCLSampleBufferComplexFloat& txSamples) = 0;

        /**
         * This callback will be called after the last call to processRFSampleBlock. It is the place to do all your
         * cleanup work.
         */
        virtual void streamingHasStopped() = 0;

        /**
         * If any error occurs during the streaming, this callback will be invoked. Streaming might or might not
         * continue after an error, depending on the type of error.
         */
        virtual void handleError (const StreamingError& error) = 0;
    };
}